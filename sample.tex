\documentclass[a4paper,11pt,titlepage]{jarticle}                                
\usepackage[dvipdfmx]{graphicx}                                                 
\usepackage{listings}                                                           
\usepackage{amsmath}                                                            
\usepackage{fancybox,ascmac}                                                    
\usepackage{url}                                                                
                                                                                
\title{知能情報実験II　:　第三回レポート}                                       
\author{175751C 宮城孝明}                                                       
\date{\today}                                                                   
                                                                                
\begin{document}                                                                
\maketitle                                                                      
\tableofcontents                                                                
\clearpage                                                                      
\section{実験目的}        
機械語(マシン語)命令をフェーズごとに実行させ,そのときのコンピュータ内部の状態を観測することにより,
各フェーズでどのような処理が行われているかを調査し,機械語命令の実行の仕組みを理解する目的とする.
\section{概要}
今回の実験は,KUE-CJIP2を用いて,1クロックフェーズだけ命令実行し,プログラムカウンタやフラグレジスタ,ACC,IX,MAR,IRの観測した.毎回を手入力し,計7回行った.次の実験としては,ソートプログラムの作成を行った.データ領域に3個のデータを予め格納しており,プログラムの実行した時に,データを取り出しソートを行うプログラムであった.比較を行い交換しないといけないため,比較の処理を行い次の処理でフラグレジスタの符号がプラスの時の処理,マイナスの時の処理をぞれそれ考える必要がある.最後の実験は,2つの非負整の商を求めるプログラムを作成するものであった.2つの整数関係だけでも5つのパターンがあるため,処理が5パターンある.商を求めるため,割られる数を割る数から引き,割られる数がマイナスになるまでこれを繰り返す.これにより,処理を完成させた.
 \section{実験結果}
 \begin{enumerate}
 	\item	 実験(1),(2),(3)の結果について\par
 		提出しているため,報告は割愛する.
 		
 	\item 実験(4)について\par

   
 	降順のプログラム\par
	　図2のフローチャートは,降順プログラムの実行を表している.まず初めの命令は,データ領域(00H)番地の値をACCに,(01H)番地の値をIXに格納する.そして,格納したACCとIXを比べ,ACCが小さければ,ACCの値を(01H)番地,IXの値を(00H)番地に格納し,それぞれを入れ替えする.ACCが大きければ,降順になっているためそのままで良いので,特に何もしないで次の命令に移る.次の命令では,データ領域 (01H)番地の値をACCに,(02H)番地の値をIXに格納する.そして,先ほどと同様にACCとIXを比べ,ACCが小さければ,ACCの値を(02H)番地,IXの値を(01H)番地と入れ替えを行う.入れ替えが終了したら,一番最初の処理に戻る.二回目の比較でACCが大きければ,降順に並んでいることになるため処理は全て終了する.\par
 \begin{figure}[htbp]
  \centering
  \includegraphics[width=38mm]{sample1.png}
  \label{実験(4)のフローチャート}\\
  \caption{実験(4)のフローチャート}
\end{figure}
\clearpage
\lstinputlisting[numbers=left,breaklines=true,basicstyle=\ttfamily\footnotesize,
   frame=sing,caption=実験(4)のコード,label=1]{Sample.s}


 	\item 実験(5)について\par
 	データ領域(00H)にmの値,(01H)にnの値を格納する.\par
 	(a)の場合の処理の手順\par
  mに14H(20),nに05H(5)の値を格納する.始めにIXとIXをXORして値を0にする.そして,ACCにデータ領域(01H)の値を代入る.ACCの値は0ではないため,そのまま処理を下に降りる.その次に,ACCにデータ領域(00H)の値を代入する.そして,現在のACCの値をデータ領域(01H)に格納されている値から引く.そして,その値をACCに格納する.ACCが0未満ではないため,処理は下の階層に続く.そして,IX(値は0)に+1ずつ加算していく.この処理は,ACCの値がマイナスになるまで続ける.マイナスになったとき,IXの値にはmとnの割り算の商の値が格納されている.これにより,IXの値を(02H)に格納し,処理を終了する.結果は,4である.\par
  \clearpage
  	(b)の場合の処理の手順\par
  	mが15H(21)で,nが04H(4)の値とする.最初の命令で,IXの中身を0にする.そして,データ領域(01H)の値を格納する.(01H)は,0出ないためそのまま降りていく.そして,ACCにデータ領域(00H)の値を格納する.そして,ACC値から(01H)を引く.もし,ACCの値がマイナスになるならジャンプ命令をするが,ACCの値はプラスのままであるため,IXに1加える命令を実行する.それをACCがマイナスになるまで続ける.IXの値が5になる時この処理は終了する.そんため,ジャンプ命令を実行し,IXをデータ領域(02H)に格納し終了する.結果は,5である.\par
  	
  	(c)の場合の処理の手順\par
  	mに00H(0),nに01H(1)を格納している.最初の命令で,IXの中身を0にする.そして,データ領域(01H)の値を格納する.(01H)は,0出ないためそのまま降りていく.そして,ACCにデータ領域(00H)の値を格納する.そして,ACC値から(01H)を引く.マイナスになってしまうのですぐにジャンプ命令に移る.この時,IXには何も加えられていながデータ領域(02H)に値を格納する.そして,処理を終了する.結果は,0である.\par
  	(d)の場合の処理の手順について\par
  	mに01H(1),nに01H(1)を格納する.最初の命令で,IXの中身を0にする.そして,データ領域(01H)の値を格納する.(01H)は,0出ないためそのまま降りていく.そして,ACCにデータ領域(00H)の値を格納する.そして,ACC値から(01H)を引く.マイナスにならないためIXに1加える.次の命令でマイナスになり,ジャンプ命令を実行し,IXの値をデータ領域に格納し,終了する.結果は,1である.\par
  	(e)の場合の処理の手順\par
  	mに01H(1),nに00H(0)を格納する.最初の命令で,IXの中身を0にする.そして,データ領域(01H)の値を格納する.ACCの値は0のためジャンプ命令を実行する.そして,IXにFFH代入し,IXの値をデータ領域(02H)に格納し終了する.\par
  	\clearpage

   
   \begin{figure}[htbp]
  \centering
  \includegraphics[width=38mm]{sample2.png}
  \label{実験(5)のフローチャート}\\
  \caption{実験(5)のフローチャート}
\end{figure}
 \end{enumerate}
 \lstinputlisting[numbers=left,breaklines=true,basicstyle=\ttfamily\footnotesize,
   frame=sing,caption=実験(5)のコード,label=2]{Sample1.s}
   
  \section{考察}
  \begin{enumerate}
  	\item 実験(1),(2),(3)の考察について\par
  		命令には,4つの段階がある.命令の読み出し,命令の解読,命令の実行,実行結果の格納に分けられる.P0の実行フェーズは,命令の読み出しが行われている.そのため,PCの値がMARに格納される.次のP1の実行フェーズは命令の解読のため,MARの値から持ってこられた命令コードをIR(インストラクションレジスタ)に格納されるその次のP2フェーズでは.命令の実行を行う.解読された命令で何を行うのかを決め,値を取り出してきて,命令実行を行う.最後のP3フェーズでは,命令の格納を行う.先ほどの命令実行で出た結果をレジスタに格納し,処理を終了する.しかし,(2)の2の命令は,データ領域から値を取り出すという作業が含まれるため他の処理も1つフェーズが多い.同じ(2)の3命令は,セットする値を変更するだけの処理のため,他の命令よりも1フェーズ少ない.\par
  		PCは,プログラムカウンタと呼ばれている.役割としては,次の実行する命令のメモリ番地を格納するレジスタである.\par
  		FLAGは,フラグと呼ばれている.2つの値か状態を0か1で判断する.命令分岐などで使われる.\par
  		MARは,メモリアドレスレジスタと呼ばれている.実行するのに必要な値が格納されているメモリ番地を格納するレジスタである.\par
  		IRは,インストラクションレジスタと呼ばれている.命令コードを格納するレジスタである.\par
  	\item	 実験(4)の考察について\par
  		3個のデータの並べ替えを限定すれば,このプログラムの修正する必要ないと判断する.このプログラムは,バブルソートを使用しているため,始めから揃っている場合でも最初から最後まで処理を通してしまうため時間を掛けてしまう.もし,始め揃っていたら処理をしないで終了のところまで移動するプログラムを作ろうとしたら,今よりもコード数が増えてしまい,可読性を損ねてしまう.\par
  		3個のデータの状態だと比較の命令が2つで十分だが,4個になると比較は3つ以上になる.5個だと4つは必要になる.しかし,上から下の処理を繰り返す条件を立てるのは厳しいため,上から下から並べ替えを行い,下から上に並べ替えを行う.こうすることで,降順に並べ替えが完成する.しかし,要素が増えれば増えるほどコード数がとても長くなるので良いコードとは思わない.\par
  	\item 実験(5)の考察について\par
  		改善する点としては,終了コードが2つあるところを1つにする必要ことが改善点である.ACCが0の時すぐにIXにFFを格納し,ジャンプ命令を行い終了する.\par
  	\item その他の考察について\par
  		本実験を通し,ソート処理のプログラミングを作成する際に,要素が増えた場合を考えたプログラムを作っていかないといけない.決まった要素だけで考えるプログラムだと,要素の増減際に対応できない.枠にはまった考えだと応用が利かないと知った.
  \end{enumerate}
  \section{調査課題}
  \begin{enumerate}
  	\item パイプラインハザードについての対策\par
  		パイプラインハザードは,次の3種類に分けられる.構造ハザードとデータハザード,制御ハザードである.\par
  		構造ハザードは,コンピュータの構造自体に問題がある.例としては,メモリの格納と読み込みが同時には実行できないという問題点である.これを解決するためには,資源の多重化をする.つまり, データメモリと命令メモリに分け,アクセスするための制御線を整備することで解決することができる.\par
  		データハザードは,命令Aの実行結果がないと命令Bを実行することができないということで発生する問題である.つまり,命令Aと命令Bが依存関係にあると言える.この問題を解決するために,フォワーリングという方法がある.これは,Eステージの結果をWステージを通すことせず,次の命令のEステージに送る.処理を行い,結果が前の命令と同じであれば,結果として出力する.\par
  		制御ハザードは,分岐命令の際に後続のどの命令になるかを決める。この時にも依存関係が発生する.無条件分岐の時には,命令アドレス生成するタイミングがわかる.Dステージの終わりで行うことができるため,効率化することができる.条件分岐の時は,遅延分岐と分岐予測を使用する.遅延分岐は,分岐するしないに関わらず,分岐命令直後に共通命令を実行しておくという方法である.分岐予測は,分岐が起きるか起きないかを予測し,外れた場合は分岐命令以下の命令を消すという方法である.予測の仕方は,分岐するしないかのどちらか一方に固定するものと,過去の履歴から決めるものなどさまざまである.
  		最後にソフトウェアを用いて,依存関係の命令同士をなるべく離し,ハザードを起きにくくする命令スケジューリングという方法もある.この方法は,コンパイラが行う.\par
  	\item ICP\par
  		コンピュータBに構造ハザードが起きて,処理に時間がかかった.\par
  		コンピュータAは,並列処理を行いコンピュータBよりも速く実行が行えた.\par
  		コンピュータBが,空き容量をうまく活用できなかった.\par
  \end{enumerate}
  \section{感想}
   今回の実験では,先のことを考えたプログラムをかけるようにならないと,後からのプログラムの拡張の際にとても苦労すると感じた.
  \section{参考文献}
  \begin{thebibliography}{99}
  	\bibitem{wiki}wiki; https://ja.wikipedia.org/wiki/命令レジスタ
  	\bibitem{tosiba}tosiba; https://toshiba.semicon\-storage.com/jp/design\-support/e\-learning/micro\_intro/chap4/1274772.html
  	\bibitem{tokyo}tokyo; https://www.mtl.t.u\-tokyo.ac.jp/~sakai/hard/hard4.pdf
  	\bibitem{コンピュータアーキテクチャ}コンピュータアーキテクチャ; 坂井 修一  2018年1月15日 コンピュータアーキテクチャ
  \end{thebibliography}
  

\end{document} 


